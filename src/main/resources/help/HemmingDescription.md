Код Хэмминга - метод кодирования, применяемый для создания самоконтролирующегося и самокорректирующего кода. Код Хэмминга используется для обеспечения целостности кода посредством его фрагментной проверки на любые изменения, возникшие при передаче. Однако данный метод эффективен для исправления только одной ошибки в фрагменте, из-за чего есть более совершенные методы, способные замечать более одной ошибки.
Пусть нам дано сообщение O, состоящее из K символов L_i, i в диапазоне (1;K). Также пусть мы определили размер одного проверяемого фрагмента 2^{x}, где x - фрагментация кодирования.
Далее представлен алгоритм кодирования произвольного сообщения O:
- Зададим число фрагментации кодирования x;
- Фрагментация кодирования x определяет набор номеров Хэмминга: H = {H_0,H_1,...,H_j}, где: H_j = 2^j, j в диапазоне (0;x);
- Переведём сообщение O в бинарный вид B, последовательно переводя символы L_i в их бинарный вид B_i по таблице ASCII:
	- N = 8K - количество бит сообщения B;
	- b_{i}, i в диапазоне (0, 8K-1) - бит бинарного сообщения B;
	- B_i = b_{i0}b_{i1}...b_{i7} - один символ в бинарном виде:
		- b_{ji} = b_{8j + i}.
- Фрагментация кодирования x определяет количество символов 2^x, которые будут отобраны последовательно из сообщения B;
- Разделяем сообщение B на набор "бинарных слов": W = {W_0,W_1,...,W_{M-1}}, где:
	- x - фрагментация кодирования;
	- M = {N} / {2^{x-1}} - количество бинарных слов;
	- W_m = b_{m0}b_{m1}...b_{mx}, m в диапазоне (0; M) - бинарное слово;
	- b_{mi} = b_{2^xm + i}, i в диапазоне (0;x-1).
- Для каждого бинарного слова W_m выполняем следующие манипуляции:
	- На индексы H_j = 2^j - 1, j в диапазоне (0;x) вставляем по одному дополнительному биту со значением 0:
	- Для каждого индекса H_j создаётся бинарная маска Z_j по следующему правилу:
		- Создаётся пустая маска Z_j размером 2^x со всеми значениями равные нулю;
		- Начиная с индекса под номером 2^j производится следующее:
			- На индексах (2^j; 2^j + j) маски Z_j вставляются значения 1;
			- Пропускается следующие 2^j индексов;
			- Производится та же вставка снова;
			- Процесс продолжается до тех пор, пока следующий индекс вставки не выходит за границы размера маски Z_j.
	- Для каждого индекса H_j происходит подсчёт суммы s побитовой "и" с бинарной маской Z_j по следующему правилу:
		- s = 0;
		- Проходим через биты бинарного слова W_m;
		- Если на одной и той же позиции в бинарном слове W_m и в маске Z_j стоит единица, то сумма инкрементируется.
	- Если s - нечётное число, то на место индекса H_j в бинарном слове W_m подставляется 1;
	- Иначе, на то же место подставляется 0.
По итогу выполнения алгоритма кодирования выше мы получим закодированное сообщение B по коду Хэффмана.
Далее представлен алгоритм проверки предоставленного сообщения B на ошибки в фрагментах:
- Дана фрагментация x;
- Длина сообщения: N;
- Вычисляем количество бинарных слов в сообщении: M = {N_1} / {2^{x-1} + x};
- Отбираем из сообщения по 2^x + M(x+1) битов, данные фрагменты составляют набор бинарных слов W;
- Проходим по каждому бинарному слову W_m:
	- Создаём копию слова W^(*)_m, в котором все индексы под номерами Хэмминга равны нулю;
	- Вычисляем заново суммы для индексов номеров Хэмминга (см. алгоритм кодирования);
	- Определяем сумму ошибки s = -1;
	- Сравниваем полученные биты под индексами номеров Хэмминга:
		- Если бит на номере j (индексе j - 1) отличается, то если s = -1 мы присваиваем s = j-1 иначе мы прибавляем индекс к сумме: s = s + j - 1.
	- Если s != -1, то на индексе s находится ошибка:
		- Для исправления ошибки, бит под индексом s меняется на противоположную.
По итогу выполнения алгоритма выше мы получим целое сообщение B, даже если в каждом фрагменте произошла одна ошибка бита.
Для того, чтобы получить изначальное сообщение O необходимо:
- Для каждого бинарного слова W_m убрать биты на позициях 2^j, j в диапазоне (0, x);
- Последовательно отобрать по 8 битов из оставшегося набора B и преобразовать их в символ, в зависимости от их значения на таблице ASCII.
Наконец у нас должно остаться изначальное сообщение O без изменений и ошибок.