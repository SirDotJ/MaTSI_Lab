Алгоритм Хаффмана - метод кодирования, предназначенный для сжатия информации без потери при помощи использования частот появления символов в сообщении.
Метод основа на предположении, что некоторые символы сообщения встречаются значительно чаще остальных, из-за чего, сократив занимаемое ими место, можно сократить объем всего сообщения.
Пусть нам дано сообщение O = {L_1,L_2,...,L_N} с произвольными вероятностями появления используемых символов P = {p_1, p_2, ..., p_n}, где:
- L_i - символ сообщения под индексом i в диапазоне (1; N);
- N - количество символов в сообщении;
- n - количество используемых символов в сообщении;
- p_j = {N_j} / {N} - вероятность использования символа l_j, в диапазоне (1,n):
	- N_j - количество появлений символа l_j в сообщении.
Вместо вероятностей также можно использовать целочисленное количество появлений символа в тексте.
Сначала строится бинарное дерево поиска символов по следующему алгоритму:
- Создаём пустое бинарное дерево T;
- Определяем элемент бинарного дерева C_i, i в диапазоне (1,n) - символы со следующими элементами:
	- Сам символ L_i;
	- Частота появления символа p_1;
	- Родитель C_{ip};
	- Левый ребёнок C_{il};
	- Правый ребёнок C_{ir}.
- Полученный список будет нашим текущим деревом;
- Создаём копию дерева T^* с ссылками на те же элементы C_i;
- Достраиваем текущее дерево T по следующему алгоритму:
	- Из копии дерева T^* выбираются два элемента C_q и C_e, с наименьшими частотами появления p_q и p_e соответственно:
		- Если в дереве T^* нет такого второго наименьшего элемента C_e (дерево T^* - имеет один элемент), то текущее дерево T - построено.
	- Для элементов C_q и C_e определяется новый элемент родитель C_p, не имеющий символа и вероятность которого вычисляется по формуле: p_p = p_q + p_e;
	- Для элемента родителя C_p определяется левый ребёнок из двух элементов C_q и C_e, у которого вероятность - наименьшая;
	- Для элемента родителя C_e определяется правый ребёнок из двух элементов C_q и C_e, у которого вероятность - наибольшая;
	- Если вероятности C_q и C_e совпадают, то дети для C_p устанавливаются произвольно;
	- Элемент C_p добавляется в деревья T^* и T;
	- Элемент C_p обозначается как коренной для дерева T;
	- Элементы C_q и C_e удаляются из дерева T^*.
По итогу выполнения алгоритма выше мы получим бинарное дерево поиска T с коренным элементом C_p. Если дерево было вычислено правильно, то значение вероятности для коренного элемента будет составлять 1 и для каждого элемента будет верно правило: вероятность элемента родителя равна сумме вероятности элементов детей.
Далее полученное бинарное дерево используется для кодирования сообщения O по следующим образом:
- Определяем пустое бинарное представление символа B;
- Отбираем новый символ L из сообщения;
- Найти данный символ в бинарном дереве можно разными способами:
	- Можно составить путь от корневого элемента по следующему правилу:
		- Если от корневого элемента необходимо пойти на лево, то вставляем в B число 0;
		- Иначе если от корневого элемента необходимо пойти на право, то вставляем в B число 1;
	- Сохранив ссылку на элемент дерева символ и получив к нему прямой доступ мы также можем найти путь но уже от конца к началу:
		- Сохраняем ссылку на текущий элемент;
		- Переходим к родительскому элементу;
		- Если левый элемент - текущий элемент, то добавляем в предпоследнюю ячейку B число 0;
		- Иначе, если правый элемент - текущий элемент, то добавляем в предпоследнюю ячейку B число 1.
	- И наконец можно заранее сохранить все соотношения между символами и их соответствующими путями и возвращать их в качестве B.
- Полученное бинарное представление символа B добавляется в конец кодированного сообщения O.
Наконец бинарное дерево поиска передаётся вместе с сообщением в максимально сжатом формате.
Получив кодированное сообщение его можно декодировать по следующему алгоритму:
- Полученную информацию о бинарном дереве используют для его воссоздания;
- Создаём пустое сообщение O;
- Используя полученное дерево проводим последовательную декодировку символов по следующему алгоритму:
	- В набор битов B добавляется следующий бит;
	- Текущий набор B используется для прохода через бинарное дерево поиска по следующему правилу:
		- Начинаем с корневого элемента дерева;
		- Берём первый бит b_0 в b и убираем его из пути B:
			- Если битов в наборе не осталось, то проверяем текущий элемент:
				- Если текущий элемент не имеет символа, то путь не определяет символ;
				- Если текущий элемент имеет символ, то путь обозначает соответствующий символ.
		- Если текущий бит b равен 0, то мы устанавливаем текущий элемент - левый:
			- Если левого элемента нет, то устанавливаем правый элемент
		- Иначе если текущий бит b равен 1, то мы устанавливаем текущий элемент - правый:
			- Если правого элемента нет, то устанавливаем левый элемент.
		- Повторяем попытку поиска вернувшись на этап отбора бита b из списка B.
	- Однако также можно заранее сохранить все допустимые пути символов в списке и искать текущий путь B в нём на совпадение;
	- Если в результате поиска мы нашли символ, то:
		- Добавляем найденный символ на конец текущего сообщения O;
		- Очищаем текущий набор битов B.
По итогу выполнения алгоритма декодирования мы получим изначальное сообщение O.