Криптосистема Рабина многим схожа по своему принципу с криптосистемой RSA, однако отличается следующими аспектами:
- Вместо возведения в произвольно большую степень, блоки информации при зашифровке возводятся в степень 2, что значительно ускоряет процесс шифрации;
- Без внесения дополнительной информации для определения настоящего блока информации, после расшифровки будет предоставлено 4 одинаково возможных варианта:
	- Для избегания неоднозначности можно вставить в блок ранее определенную метку или контрольную сумму.

При использовании криптосистемы Рабина определяют два ключа:
- Открытый ключ: n;
- Закрытый ключ: (p, q, a, b).

Ключи создаются по следующему алгоритму:
- Выбирают два случайных различных простых числа p и q, которые при делении на 4 оставляют остаток 3 (p % 4 = 3, q % 4 = 3);
- Вычисляется открытый ключ n = p * q;
- При помощи расширенного алгоритма Евклида (представленного далее) находят такие целые числа a и b (коэффициенты Безу), что a * p + b * q = 1.

Коэффициенты Безу вычисляются так:
- Пусть даны числа p и q и для них необходимо найти такие a и b, что a * p + b * q = 1;
- Определим:
	- oldR = p;
	- r = q;
	- oldS = 1;
	- s = 0;
	- oldT = 0;
	- t = 1.
- Пока r != 0 выполняем следующие действия:
	- Вычисляем quotient = oldR / r - целая часть от деления oldR на r;
	- Определяем tempOldR = oldR;
	- oldR = r;
	- r = tempOldR - quotient * r;
	- Определяем tempOldS = oldS;
	- oldS = s;
	- s = tempOldS - quotient * s;
	- Определяем tempOldT = oldT;
	- oldT = t;
	- t = tempOldT - quotient * t.
- По итогу выполнения цикла:
	- oldS = a;
	- oldT = b;
	- oldR = НОД(p, q).
Из-чего мы получаем числовые значения коэффициентов Безу a и b.

В итоге выполнения алгоритма генерации ключей мы получаем:
- Закрытый ключ (p, q, a, b);
- Открытый ключ n.

Зашифровка происходит следующим образом:
- Пусть пользователю необходимо передать сообщение M, которое можно представить в числовом виде (M_0, M_1, ..., M_{n-1}) в соответствии с таблицей №1, где n - количество блоков в сообщении;
- В каждому числовому блоку сообщения добавляется заранее определенная метка:
	- В данной реализации в начало блока добавляется произвольное числовое значение, по которому сверяется результат расшифровки при выборе кандидата.
- Отправитель имеет доступ к открытому ключу n;
- Зашифрованное сообщение c = (c_0, c_1, ..., c_n) вычисляется по формуле: c_i = M_i^2 % n, iв диапазоне (0,n-1).
В итоге мы получаем зашифрованное сообщение c = (c_0,c_1,...,c_{n-1}).

Расшифровка сообщения проводится по следующему алгоритму:
- Пусть пользователь получил зашифрованное сообщение c, состоящее из числовых блоков c_i, iв диапазоне (0,n-1);
- У получателя есть доступ к закрытому ключу: (p, q, a, b);
- Вычислим значения r = (r_0,r_1,...,r_{n-1}) и s = (s_0,s_1,...,s_{n-1}) при помощи формул:
	- r_i = c_i^{(p + 1)/4} % p;
	- s_i = c_i^{(q + 1)/4} % q.
- Вычислим 4 набора кандидатов расшифровки блоков:
	- V_1 = (V_{10},V_{11},...,V_{1n-1}) по формуле V_{1i} = (aps_i + bqr_i) % n, iв диапазоне (0,n-1);
	- V_2 = (V_{20},V_{21},...,V_{2n-1}) по формуле V_{2i} = -V_{1i}, iв диапазоне (0,n-1);
	- V_3 = (V_{30},V_{31},...,V_{3n-1}) по формуле V_{1i} = (aps_i - bqr_i) % n, iв диапазоне (0,n-1);
	- V_4 = (V_{40},V_{41},...,V_{4n-1}) по формуле V_{4i} = -V_{3i}, iв диапазоне (0,n-1).
- Для блока M_i настоящий вариант из кандидатов V_{1i}, V_{2i}, V_{3i}, V_{4i} выбирается в зависимости от определенной ранее метки настоящего значения.
В итоге получатель получает расшифрованное сообщение M = (M_0,M_1,...,M_{n-1}) из зашифрованного c = (c_0,c_1,...,c_{n-1}).